---
title: "SQLite and iOS: Getting started with GRDB"
date: 2019-12-09
category: Code
tags:
  - Swift
  - Database
---

import { Box } from '@theme-ui/components';

Designed to provide *local* data storage for individual applications and
devices, SQLite is a small, fast, highly reliable SQL database engine that
I have a lot of love for.

In this article we'll cover setting up a local SQLite database for your iOS
app, writing migrations, modelling the data to a struct, and querying.

[GRDB](https://github.com/groue/GRDB.swift) is a fantastic SQLite toolkit
maintained by [Gwendal RouÃ©](https://github.com/groue) that does all the hard
work for us: it provides, amongst other features, a query interface so we don't
have to write raw SQL (though you can still do that if you need to),
migrations, database observation, and encryption. It's what I use in my own
projects, and it's what we'll be using in this article.

### Part 1: How to setup GRDB in your app

This section will cover installing GRDB, creating the database file, connecting
to it, and writing a migration.

#### Installation

First things first, you need to add GRDB to your project. Carthage isn't
supported, but CocoaPods and the Swift Package Manager are.

```ruby:title=Podfile
pod 'GRDB.swift'
```

```swift:title=Package.swift
let package = Package(
    dependencies: [
        .package(url: "https://github.com/groue/GRDB.swift.git", ...)
    ]
)
```

#### Creating the database file and connecting to it

Now that GRDB is installed, we can get down to business. Create a file named
DatabaseManager.swift, AppDatabase.swift, or something similar. This is where
your migrations will live alongside the database setup function.

```swift:title=DatabaseManager.swift
import GRDB

var dbQueue: DatabaseQueue!

class DatabaseManager {

    static func setup(for application: UIApplication) throws {
        let databaseURL = try FileManager.default
            .url(for: .applicationDirectory, in: .userDomainMask, appropriateFor: nil, create: true)
            .appendingPathComponent("db.sqlite")

        dbQueue = try DatabaseQueue(path: databaseURL.path)
        dbQueue.setupMemoryManagement(in: application)
    }

}
```

Right at the top on line 3 you'll see the global `dbQueue` variable. The
connection to the database gets closed when the `DatabaseQueue` gets
deallocated, so for most use cases you'll want it kept in memory throughout the
life cycle of your app.

You'll notice that we never explicitly create the db.sqlite file, we just
compose its path. That's because `try DatabaseQueue(...)` on line 12 will
automatically create the database file for us if it can't find an existing one.

`setupMemoryManagement` on line 13 tells GRDB to automatically run
`dbQueue.releaseMemory()` both when your app enters the background and if your
app receives memory warnings. `releaseMemory` will then free up as much of the
memory GRDB is using as possible.

All that's left to do is actually call the `setup` method in your AppDelegate:

```swift:title=AppDelegate.swift {2}
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    try! DatabaseManager.setup(for: application)
    return true
}
```

### Adding migrations

Now that we have a database and a connection to it, we need to populate it.
Before data can be inserted though, we need to create a table and columns.

GRDB's `DatabaseMigrator` is responsible for registering and applying
migrations.

```swift:title=DatabaseManager.swift
class DatabaseManager {

    static var migrator: DatabaseMigrator {
        var migrator = DatabaseMigrator()

        migrator.registerMigration("createProject") { db in
            try db.create(table: "project") { t in
                t.autoIncrementedPrimaryKey("id")
                t.column("name", .text).notNull()
            }
        }

        return migrator
    }

}
```

The above is fairly self-explanatory, but we'll run through it quickly just in
case.

You can see that line 6 marks the start of a new migration. If you're
unfamiliar with the concept, migrations provide an easy way to modify the
structure of the database over time. **They are guranteed to be applied in
order, and only once.** What that means is that when your user updates your app
and you've added a migration or two, only the non-applied migrations will run.

Line 7 creates a new table named `project`, then lines 8 and 9 specify the
name, type, and characteristics of 2 columns. `autoIncrementedPrimaryKey` is
the best way to define a primary key that's numeric as it automatically
prevents reuse of the value over the lifetime of the database.

Don't forget to update your `setup` method to actually run the migrations.

```swift:title=DatabaseManager.swift {5}
class DatabaseManager {

    static func setup(for application: UIApplication) throws {
        // Existing setup codeâ€¦
        try migrator.migrate(dbQueue)
    }

}
```

Should you need to make alterations to your tables in future versions of your
app, you can do so quite straightforwardly by registering a new migration.

```swift
migrator.registerMigration("v2") { db in
    try db.alter(table: "project") { t in
        t.add(column: "isDraft", .boolean).defaults(to: true)
    }

    try db.rename(table: "project", to: "collection")
}
```


<Box p={4} color='white' bg='secondary'>
ðŸ’¡ Tip from the GRDB docs

Database table names should be singular and camel-cased (e.g. country,
postalAddress). Names that follow another convention are totally OK, but you
will need to perform extra configuration when using Associations.
</Box>

---

### Part 2: Populating your database

This section will cover installing GRDB, creating the database file, connecting
to it, and writing a migration.
